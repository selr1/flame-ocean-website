/**
 * Consistency tests to verify TypeScript implementation produces identical output to Python
 *
 * These tests load procedural data generated by the Python implementation
 * and verify that the TypeScript version produces exactly the same output.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'node:fs';
import { join } from 'node:path';
import { convertToBmp, createMonoBmp } from '../utils/bitmap.js';
import { swapBytes16Bit, restrideToBmp, createBmpHeader } from '../utils/bytes.js';
import { FontExtractor } from '../extractors/font-extractor.js';
import type { FirmwareAddresses, PixelData } from '../types/index.js';

interface TestData {
	bitmap_conversion: TestCase[];
	font_decoding: TestCase[];
	misalignment_detection: TestCase[];
}

interface TestCase {
	name: string;
	input: unknown;
	output: unknown;
}

/**
 * Load Python test data
 */
function loadPythonTestData(): TestData {
	const dataPath = join(__dirname, 'data', 'python_test_data.json');
	const data = readFileSync(dataPath, 'utf-8');
	return JSON.parse(data) as TestData;
}

/**
 * Compare arrays for equality
 */
function arraysEqual<T>(a: T[], b: T[]): boolean {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) return false;
	}
	return true;
}

/**
 * Convert regular array to Uint8Array for comparison
 */
function toUint8Array(arr: number[]): Uint8Array {
	return new Uint8Array(arr);
}

// Load test data immediately
const pythonTestData = loadPythonTestData();

// Create a mock firmware and FontExtractor for decodeV8 tests
const mockFirmware = new Uint8Array(0x100000);
const mockAddresses: FirmwareAddresses = {
	SMALL_BASE: 0x10000,
	LARGE_BASE: 0x20000,
	LOOKUP_TABLE: 0x80000,
	confidence: {
		smallFontValid: 3,
		largeFontValid: 3,
		movw0042Count: 12
	}
};
const fontExtractor = new FontExtractor(mockFirmware, mockAddresses);

describe('Python Consistency Tests - Bitmap Conversion', () => {
	const tests = pythonTestData.bitmap_conversion;

	tests.forEach((testCase) => {
		it(`Python: ${testCase.name}`, () => {
			const input = testCase.input as { raw_data?: number[]; width?: number; height?: number; data?: number[] };

			if (testCase.name.includes('RGB565 to BMP') && !testCase.name.includes('invalid')) {
				// Test convertToBmp
				const rawData = toUint8Array(input.raw_data ?? []);
				const width = input.width ?? 0;
				const height = input.height ?? 0;

				const result = convertToBmp(rawData, width, height);
				const expectedOutput = testCase.output as { bmp_data?: number[] };

				expect(result).not.toBeNull();
				expect(arraysEqual(Array.from(result!), expectedOutput.bmp_data ?? [])).toBe(true);
			} else if (testCase.name.includes('invalid')) {
				// Test invalid dimensions
				const rawData = toUint8Array(input.raw_data ?? []);
				const width = input.width ?? 0;
				const height = input.height ?? 0;

				const result = convertToBmp(rawData, width, height);
				const expectedOutput = testCase.output as { result: null };

				expect(result).toBe(expectedOutput.result);
			} else if (testCase.name.includes('swap_bytes_16bit')) {
				// Test swapBytes16Bit
				const data = toUint8Array(input.data ?? []);
				const expectedOutput = testCase.output as { swapped: number[] };

				const result = swapBytes16Bit(data);
				expect(arraysEqual(Array.from(result), expectedOutput.swapped)).toBe(true);
			} else if (testCase.name.includes('get_stride_info')) {
				// Test stride info
				const width = input.width as number;
				const expectedOutput = testCase.output as { src_stride: number; dst_stride: number; padding: number };

				// Calculate stride info
				const srcStride = width * 2;
				const dstStride = (srcStride + 3) & ~3;
				const padding = dstStride - srcStride;

				expect({
					src_stride: srcStride,
					dst_stride: dstStride,
					padding
				}).toEqual(expectedOutput);
			} else if (testCase.name.includes('restride_to_bmp')) {
				// Test restrideToBmp
				const rawData = toUint8Array(input.raw_data ?? []);
				const width = input.width ?? 0;
				const height = input.height ?? 0;
				const expectedOutput = testCase.output as { aligned_data: number[] };

				const result = restrideToBmp(rawData, width, height);
				expect(arraysEqual(Array.from(result), expectedOutput.aligned_data)).toBe(true);
			} else if (testCase.name.includes('create_bmp_header')) {
				// Test createBmpHeader
				const width = input.width ?? 0;
				const height = input.height ?? 0;
				const expectedOutput = testCase.output as { header: number[]; header_size: number };

				const result = createBmpHeader(width, height);
				expect(arraysEqual(Array.from(result), expectedOutput.header)).toBe(true);
				expect(result.length).toBe(expectedOutput.header_size);
			}
		});
	});
});

describe('Python Consistency Tests - Font Decoding', () => {
	const tests = pythonTestData.font_decoding;

	tests.forEach((testCase) => {
		it(`Python: ${testCase.name}`, () => {
			const input = testCase.input as { chunk?: number[]; lookup_val?: number; width?: number; height?: number; pixels?: PixelData };

			if (testCase.name.includes('decode_v8')) {
				// Test decodeV8 function
				const chunk = toUint8Array(input.chunk ?? []);
				const lookupVal = input.lookup_val ?? 0;
				const expectedOutput = testCase.output as { pixels: number[][] };

				const result = fontExtractor.decodeV8(chunk, lookupVal);

				// Compare pixel arrays (Python stores as 0/1 integers, TypeScript uses booleans)
				expect(result.length).toBe(expectedOutput.pixels.length);
				for (let y = 0; y < result.length; y++) {
					expect(result[y].length).toBe(expectedOutput.pixels[y].length);
					for (let x = 0; x < result[y].length; x++) {
						// Convert Python integer (0/1) to boolean for comparison
						const expectedBool = expectedOutput.pixels[y][x] === 1;
						expect(result[y][x]).toBe(expectedBool);
					}
				}
			} else if (testCase.name.includes('write_bmp_header_only')) {
				// Test monochrome BMP header creation
				const width = input.width ?? 16;
				const height = input.height ?? 16;
				const expectedOutput = testCase.output as { header: number[]; header_size: number };

				// Create a simple pixel pattern
				const pixels: boolean[][] = [];
				for (let y = 0; y < height; y++) {
					const row: boolean[] = [];
					for (let x = 0; x < width; x++) {
						row.push(false);
					}
					pixels.push(row);
				}

				const result = createMonoBmp(pixels as PixelData, width, height);

				// Check header matches (first 62 bytes are header)
				const resultHeader = Array.from(result.slice(0, 62));
				expect(resultHeader).toEqual(expectedOutput.header);
				expect(result.length).toBeGreaterThanOrEqual(expectedOutput.header_size);
			} else if (testCase.name.includes('encode_mono_bmp_pixels')) {
				// Test monochrome BMP pixel encoding
				const pixels = input.pixels as PixelData;
				const width = input.width ?? 16;
				const height = input.height ?? 16;
				const expectedOutput = testCase.output as { pixel_data: number[] };

				const result = createMonoBmp(pixels, width, height);

				// The pixel data starts at offset 62 (after header)
				const resultPixelData = Array.from(result.slice(62));
				expect(resultPixelData).toEqual(expectedOutput.pixel_data);
			}
		});
	});
});

describe('Python Consistency Tests - Misalignment Detection', () => {
	const tests = pythonTestData.misalignment_detection;

	tests.forEach((testCase) => {
		it(`Python: ${testCase.name}`, () => {
			const input = testCase.input as {
				rock26_offsets: number[];
				metadata_entries: Array<{ index: number; offset: number; width: number; height: number; name: string }>;
			};

			const expectedOutput = testCase.output as {
				offset_shift_votes: Record<string, number>;
				best_shift: number;
				confidence: number;
			};

			// Simulate the misalignment detection logic
			const offsetShiftVotes = new Map<number, number>();

			for (let rock26Idx = 0; rock26Idx < Math.min(20, input.rock26_offsets.length); rock26Idx++) {
				const rock26OffsetVal = input.rock26_offsets[rock26Idx];

				for (let shift = -3; shift <= 3; shift++) {
					const metadataIdx = rock26Idx + shift;

					if (metadataIdx >= 0 && metadataIdx < input.metadata_entries.length) {
						const metadataOffsetVal = input.metadata_entries[metadataIdx].offset;

						if (metadataOffsetVal === rock26OffsetVal) {
							offsetShiftVotes.set(shift, (offsetShiftVotes.get(shift) ?? 0) + 1);
						}
					}
				}
			}

			// Convert Map to Record for comparison
			const votesRecord: Record<string, number> = {};
			for (const [shift, count] of offsetShiftVotes.entries()) {
				votesRecord[shift.toString()] = count;
			}

			// Find best shift
			let bestShift = 0;
			let confidence = 0;
			for (const [shift, count] of offsetShiftVotes.entries()) {
				if (count > confidence) {
					confidence = count;
					bestShift = shift;
				}
			}

			expect(votesRecord).toEqual(expectedOutput.offset_shift_votes);
			expect(bestShift).toBe(expectedOutput.best_shift);
			expect(confidence).toBe(expectedOutput.confidence);
		});
	});
});
